#! /usr/bin/python

# -----------------------------------------------------------------------------------------------------------------------------
# GENERAL
# -----------------------------------------------------------------------------------------------------------------------------
#
# author: Sebastiaan Van Hoecke
# mail: sebastiaan@sevaho.io
#
# NOTE:
#
# -----------------------------------------------------------------------------------------------------------------------------

import sys
import getopt
import socket
import codecs

# -----------------------------------------------------------------------------------------------------------------------------
# GLOBAL VARIABLES
# -----------------------------------------------------------------------------------------------------------------------------

decode_hex = codecs.getdecoder("hex_codec")

ETH_HDR_LEN     = 14
ARP_HDR_LEN     = 28
IPv4_HDR_LEN    = 20
IPv6_HDR_LEN    = 40
TCP_HDR_LEN     = 20
UDP_HDR_LEN	= 8

IP_PROTOCOLS_CODES = {
    '11': 'udp',
    '01': 'icmp',
    '06': 'tcp',
}

ETH_PROTOCOL_CODES = {
    '0800': 'ipv4',
    '0806': 'arp',
    '86dd': 'ipv6',
}


# -----------------------------------------------------------------------------------------------------------------------------
# CLASSES
# -----------------------------------------------------------------------------------------------------------------------------


class ETH ():

    def __init__(self, data):
        self.dst = data[0:6].hex()
        self.src = data[6:12].hex()
        self.code = eth_code_lookup(data[12:ETH_HDR_LEN].hex())


class IPv4 ():


    def __init__(self, data):
        global IPv4_HDR_LEN

        self.version = data[0:1].hex()[0]
        self.ihl = data[0:1].hex()[1]
        self.dscp = data[1:2].hex() # last 2 bits are ECN explicit congestion notification
        self.ttl = data[2:4].hex()
        self.id = data[4:6].hex()
        self.fragmentoffset = data[6:8].hex() # first 3 bits are flags
        self.ttl = data[8:9].hex()
        self.protocol = ipv4_protocol_lookup(data[9:10].hex())
        self.checksum = data[10:12].hex()
        self.src = socket.inet_ntoa(data[12:16])
        self.dst = socket.inet_ntoa(data[16:20])

        if int(self.ihl, 16) > 5:
            print("----------- IHL MORE THAN 5")
            IPv4_HDR_LEN = int(self.ihl, 16) * 4
            self.options = data[20:IPv4_HDR_LEN].hex()
        else:
            IPv4_HDR_LEN = 20

        if not hasattr(self, 'options'):
            self.options = 'none'


class IPv6 ():

    def __init__(self, data):
        self.version = data[0:1].hex()[0]
        self.traffic_class = data[0:1].hex()[1] + data[1:2].hex()[0]
        self.flow_label = data[1:2].hex()[1] + data[2:4].hex()
        self.payloadlength = data[4:6].hex()
        self.nextheader = ipv4_protocol_lookup(data[6:7].hex())
        self.hoplimit = data[7:8].hex()
        self.src = data[8:24].hex()
        self.dst = data[24:40].hex()


class TCP ():


    def __init__(self, data):
        global TCP_HDR_LEN

        self.src = int(data[0:2].hex(), 16)
        self.dst = int(data[2:4].hex(), 16)
        self.seqnumber = data[4:8].hex()
        self.ack = data[8:12].hex()
        self.data_offset = data[12:13].hex()[0]
        self.reserved = data[12:13].hex()[1] # last bit is NS, ECN nonce
        self.flags = data[13:14].hex()
        self.windowsize = data[14:16].hex()
        self.checksum = data[16:18].hex()
        self.urgent_pointer = data[16:18].hex()

        if int(self.data_offset, 16) > 5:
            TCP_HDR_LEN = int(self.data_offset, 16) * 4
            self.options = data[20:TCP_HDR_LEN].hex()
        else:
            TCP_HDR_LEN = 20


class UDP ():

    def __init__(self, data):
        self.src = int(data[0:2].hex(), 16)
        self.dst = int(data[2:4].hex(), 16)
        self.length = data[4:6].hex()
        self.checksum = data[6:8].hex()


class ICMP ():

    def __init__(self, data):
        self.type = data[0:1].hex()
        self.code = data[1:2].hex()
        self.checksum = data[2:4].hex()
        self.body = data[4:8].hex()


class ICMPv6 ():

    def __init__(self, data):
        self.type = data[0:1].hex()
        self.code = data[1:2].hex()
        self.checksum = data[2:4].hex()
        self.body = data[4:8].hex()


class ARP ():

    def __init__(self, data):
        self.type = data[0:1].hex()

# -----------------------------------------------------------------------------------------------------------------------------
# FUNCTIONS
# -----------------------------------------------------------------------------------------------------------------------------


def usage ():

    print("Usage: python %s [OPTIONS]... [ARGS]... \
            \n \
            \n\tdescription\
            \n \
            \nOPTIONS:\
            \n \
            \n\t-h, *               display the help and exit \
            \n\t-t, --target        target \
            \n\t-p, --port          port \
            \n \
            \nEXAMPLES:\
            \n \
            \n\tpython %s -t 127.0.0.1 -p 8000 \
            \n \
            \nNOTE:\
            \n \
            " % (sys.argv[0], sys.argv[0]))

    sys.exit(1)


def banner ():

    print("A Banner \
            \n \
            ")


def ipv4_protocol_lookup (protocol):

    if protocol in IP_PROTOCOLS_CODES:
        return IP_PROTOCOLS_CODES[protocol]
    else:
        return protocol


def eth_code_lookup (code):

    if code in ETH_PROTOCOL_CODES:
        return ETH_PROTOCOL_CODES[code]
    else:
        return code


def hexdump(src, length=8):
    src = str(src)
    result = []
    digits = 2
    for i in range(0, len(src), length):
        s = src[i:i + length]
        print(s)
        hexa = b' '.join([b"%0*X" % (digits, ord(x)) for x in s])
        text = b''.join([str.encode(str(x)) if 0x20 <= ord(x) < 0x7F else '.' for x in s])
        result.append(b"%04X   %-*s   %s" % (i, length * (digits + 1), hexa, text))
    return b'\n'.join(result)


def convert_hex_to_ascii(hex):
    return decode_hex(hex)[0]

# -----------------------------------------------------------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------------------------------------------------------


def main (argv):

    banner()

    # atleast 1 argument required
    # if not len(argv):
    #     usage()

    try:

        opts, args = getopt.getopt(argv, "ha:", ["help"])

    except getopt.GetoptError as err:

        print("error: %s" % (str(err)))
        usage()

    for opt, arg in opts:

        if opt in ("-h", "--help"):
            usage()
        elif opt in ("-a", "--arg1"):
            print(arg)
        else:
            assert False, "Unhandled Option"

    sniffer = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))
    sniffer.bind(('wlp4s0', 0))

    while True:
        data = sniffer.recvfrom(65535)
        data = data[0]
        eth = ETH(data)

        
        # if eth.code == 'ipv4':
        #     ip = IPv4(data[ETH_HDR_LEN:ETH_HDR_LEN + IPv4_HDR_LEN])
        #     if ip.protocol == 'udp':
        #         udp = UDP(data[ETH_HDR_LEN + IPv4_HDR_LEN:ETH_HDR_LEN + IPv4_HDR_LEN + UDP_HDR_LEN])
        #         # if int(tcp.dst) == 80 or int(tcp.src) == 80:
        #         # print("\t options: ", tcp.options)
        #         print(convert_hex_to_ascii(data[IPv4_HDR_LEN + ETH_HDR_LEN + UDP_HDR_LEN:].hex()))
        # print("==================================================================================")
        # print("eth code %s", eth.code)
        # print("eth src %s", eth.src)
        # print("eth dst %s", eth.dst)
        if eth.code == 'ipv6':
            ip = IPv6(data[ETH_HDR_LEN:ETH_HDR_LEN + IPv6_HDR_LEN])
            print("\tip v6 src", ip.src)
            print("\tip v6 dst", ip.dst)
            print("\tip v6 nextheader", ip.nextheader)
            if ip.nextheader == 'tcp':
                tcp = TCP(data[ETH_HDR_LEN + IPv6_HDR_LEN:ETH_HDR_LEN + IPv6_HDR_LEN + TCP_HDR_LEN])
                print("\t\ttcp src", tcp.src)
                print("\t\ttcp dst", tcp.dst)
                print("----------")
                print("\t\t\t", convert_hex_to_ascii(data[IPv6_HDR_LEN + ETH_HDR_LEN + TCP_HDR_LEN:].hex()))
                print("----------")
            if ip.nextheader == 'udp':
                udp = UDP(data[ETH_HDR_LEN + IPv6_HDR_LEN:ETH_HDR_LEN + IPv6_HDR_LEN + UDP_HDR_LEN])
                print("\t\tudp src", udp.src)
                print("\t\tudp dst", udp.dst)
                print("----------")
                print("\t\t\t", convert_hex_to_ascii(data[IPv4_HDR_LEN + ETH_HDR_LEN + UDP_HDR_LEN:].hex()))
                print("----------")
        if eth.code == 'ipv4':
            ip = IPv4(data[ETH_HDR_LEN:ETH_HDR_LEN + IPv4_HDR_LEN])
            print("\tip v4 src", ip.src)
            print("\tip v4 dst", ip.dst)
            print("\tip v4 protocol", ip.protocol)
            if ip.protocol == 'tcp':
                tcp = TCP(data[ETH_HDR_LEN + IPv4_HDR_LEN:ETH_HDR_LEN + IPv4_HDR_LEN + TCP_HDR_LEN])
                print("\t\ttcp src", tcp.src)
                print("\t\ttcp dst", tcp.dst)
                print("----------")
                print("\t\t\t", convert_hex_to_ascii(data[IPv4_HDR_LEN + ETH_HDR_LEN + TCP_HDR_LEN:].hex()))
                print("----------")
            if ip.protocol == 'udp':
                udp = UDP(data[ETH_HDR_LEN + IPv4_HDR_LEN:ETH_HDR_LEN + IPv4_HDR_LEN + UDP_HDR_LEN])
                print("\t\tudp src", udp.src)
                print("\t\tudp dst", udp.dst)
                print("----------")
                print("\t\t\t", convert_hex_to_ascii(data[IPv4_HDR_LEN + ETH_HDR_LEN + UDP_HDR_LEN:].hex()))
                print("----------")

        print()


if __name__ == "__main__":

    main(sys.argv[1:])
